================================================================================
Function call
================================================================================

EllipticCurve("11a1");

---
(program
  (expression_statement
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (string)))))

================================================================================
Basic definition function 
================================================================================

function test()
    return 0;
end function;

---

(program
  (function_definition
    name: (identifier)
    parameters: (parameters)
    body: (block
      (return_statement
        (integer)))))

================================================================================
Function definition with arguments
================================================================================

function test(x,y : z := 3)
    x := x + y;
    return x + z;
end function;

---

(program
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier)
      (optional_parameter
        name: (identifier)
        value: (integer)))
    body: (block
      (assignment
        left: (identifier)
        right: (binary_operator
          left: (identifier)
          right: (identifier)))
      (return_statement
        (binary_operator
          left: (identifier)
          right: (identifier))))))

================================================================================
Function definition with := notation
================================================================================

fibonacci := function(n)
   if n le 2 then
      return 1;
   else
      return $$(n-1) + $$(n-2);
   end if;
end function;

---

; copied from example H2E1
(program
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier))
    body: (block
      (if_statement
        condition: (comparison_operator
          left: (identifier)
          right: (integer))
        consequence: (block
          (return_statement
            (integer)))
        alternative: (else_clause
          consequence: (block
            (return_statement
              (binary_operator
                left: (double_dollar
                  (argument_list
                    argument: (binary_operator
                      left: (identifier)
                      right: (integer))))
                right: (double_dollar
                  (argument_list
                    argument: (binary_operator
                      left: (identifier)
                      right: (integer))))))))))))

================================================================================
Procedure definition with no arguments
================================================================================

procedure main()
    print "Hello, World!";
end procedure;

---

(program
  (procedure_definition
    name: (identifier)
    parameters: (parameters)
    body: (block
      (print_statement
        (string)))))

================================================================================
Procedure definition and modifying arguments
================================================================================

procedure foobar(~foo, ~bar)
    print foo;
    print bar;
    foo, bar := bar, foo;
end procedure;

---

(program
  (procedure_definition
    name: (identifier)
    parameters: (parameters
      (ref_identifier
        (identifier))
      (ref_identifier
        (identifier)))
    body: (block
      (print_statement
        (identifier))
      (print_statement
        (identifier))
      (assignment
        left: (identifier)
        left: (identifier)
        right: (identifier)
        right: (identifier)))))

================================================================================
Procedure definition with := notation
================================================================================

CheckPythagoras := procedure(x, y, z, ~h)
    if x^2+y^2 eq z^2 then
        h := true;
    else
        h := false;
    end if;
end procedure;

---

; adapted from example H2E5
(program
  (procedure_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier)
      (identifier)
      (ref_identifier
        (identifier)))
    body: (block
      (if_statement
        condition: (comparison_operator
          left: (binary_operator
            left: (binary_operator
              left: (identifier)
              right: (integer))
            right: (binary_operator
              left: (identifier)
              right: (integer)))
          right: (binary_operator
            left: (identifier)
            right: (integer)))
        consequence: (block
          (assignment
            left: (identifier)
            right: (true)))
        alternative: (else_clause
          consequence: (block
            (assignment
              left: (identifier)
              right: (false))))))))

============================
Inline function expressions
============================

myfunc := func<| x + 1>;
myproc := proc<| f(x)>;

---

(program
  (assignment
    left: (identifier)
    right: (inline_function
      body: (binary_operator
        left: (identifier)
        right: (integer))))
  (assignment
    left: (identifier)
    right: (inline_procedure
      body: (call
        function: (identifier)
        arguments: (argument_list
          argument: (identifier))))))

============================
Inline functions with parameters
============================

add := func<x, y | x + y>;
print_and_return := proc<~result, value | Print(result, value)>;

---

(program
  (assignment
    left: (identifier)
    right: (inline_function
      parameters: (identifier)
      parameters: (identifier)
      body: (binary_operator
        left: (identifier)
        right: (identifier))))
  (assignment
    left: (identifier)
    right: (inline_procedure
      parameters: (ref_identifier
        (identifier))
      parameters: (identifier)
      body: (call
        function: (identifier)
        arguments: (argument_list
          argument: (identifier)
          argument: (identifier))))))

============================
Optional parameters in procedures
============================

procedure test1(entries:Dir); x := 1; end procedure;
procedure test2(x, y:Default := 5); y := 2; end procedure;
procedure test3(a, b, c, d:Opt2 := 10); z := 3; end procedure;

---

(program
  (procedure_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier))
    body: (block
      (assignment
        left: (identifier)
        right: (integer))))
  (procedure_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier)
      (optional_parameter
        name: (identifier)
        value: (integer)))
    body: (block
      (assignment
        left: (identifier)
        right: (integer))))
  (procedure_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier)
      (identifier)
      (identifier)
      (optional_parameter
        name: (identifier)
        value: (integer)))
    body: (block
      (assignment
        left: (identifier)
        right: (integer)))))


============================
Exit statements
============================

try
    x := 1;
    exit NO_RESPAWN;
    y := 2;
catch e
    print "Error:", e;
end try;

---

(program
  (try_catch_statement
    (block
      (assignment
        left: (identifier)
        right: (integer))
      (exit_statement
        (identifier))
      (assignment
        left: (identifier)
        right: (integer)))
    error: (identifier)
    (block
      (print_statement
        (string)
        (identifier)))))

============================
More inline function examples
============================

add := func<x, y | x + y>;
multiply := func<a, b | a * b>;
increment := proc<~x | Append(~x, 1)>;
swap := proc<~a, ~b | Print(a, b)>;
factorial := func<n | n le 1 select 1 else n * $$(n-1)>;
fibonacci := func<n | n le 1 select n else $$(n-1) + $$(n-2)>;

---
(program
  (assignment
    left: (identifier)
    right: (inline_function
      parameters: (identifier)
      parameters: (identifier)
      body: (binary_operator
        left: (identifier)
        right: (identifier))))
  (assignment
    left: (identifier)
    right: (inline_function
      parameters: (identifier)
      parameters: (identifier)
      body: (binary_operator
        left: (identifier)
        right: (identifier))))
  (assignment
    left: (identifier)
    right: (inline_procedure
      parameters: (ref_identifier
        (identifier))
      body: (call
        function: (identifier)
        arguments: (argument_list
          argument: (unary_operator
            right: (identifier))
          argument: (integer)))))
  (assignment
    left: (identifier)
    right: (inline_procedure
      parameters: (ref_identifier
        (identifier))
      parameters: (ref_identifier
        (identifier))
      body: (call
        function: (identifier)
        arguments: (argument_list
          argument: (identifier)
          argument: (identifier)))))
  (assignment
    left: (identifier)
    right: (inline_function
      parameters: (identifier)
      body: (comparison_operator
        left: (identifier)
        right: (ternary_operator
          conditional: (integer)
          then: (integer)
          else: (binary_operator
            left: (identifier)
            right: (double_dollar
              (argument_list
                argument: (binary_operator
                  left: (identifier)
                  right: (integer)))))))))
  (assignment
    left: (identifier)
    right: (inline_function
      parameters: (identifier)
      body: (comparison_operator
        left: (identifier)
        right: (ternary_operator
          conditional: (integer)
          then: (identifier)
          else: (binary_operator
            left: (double_dollar
              (argument_list
                argument: (binary_operator
                  left: (identifier)
                  right: (integer))))
            right: (double_dollar
              (argument_list
                argument: (binary_operator
                  left: (identifier)
                  right: (integer))))))))))
