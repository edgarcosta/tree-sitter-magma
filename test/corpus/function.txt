================================================================================
Function call
================================================================================

EllipticCurve("11a1");

---
(program
  (expression_statement
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (string)))))

================================================================================
Basic definition function 
================================================================================

function test()
    return 0;
end function;

---

(program
  (expression_statement
    (function_definition
      name: (identifier)
      parameters: (parameters)
      body: (block
        (return_statement
          (integer))))))

================================================================================
Function definition with arguments
================================================================================

function test(x,y : z := 3)
    x := x + y;
    return x + z;
end function;

---

(program
  (expression_statement
    (function_definition
      name: (identifier)
      parameters: (parameters
        (identifier)
        (identifier)
        (optional_parameter
          name: (identifier)
          value: (integer)))
      body: (block
        (assignment
          left: (identifier)
          right: (binary_operator
            left: (identifier)
            right: (identifier)))
        (return_statement
          (binary_operator
            left: (identifier)
            right: (identifier)))))))

================================================================================
Function definition with := notation
================================================================================

fibonacci := function(n)
   if n le 2 then
      return 1;
   else
      return $$(n-1) + $$(n-2);
   end if;
end function;

---

; copied from example H2E1
(program
  (assignment
    left: (identifier)
    right: (function_definition
      parameters: (parameters
        (identifier))
      body: (block
        (if_statement
          condition: (binary_operator
            left: (identifier)
            right: (integer))
          consequence: (block
            (return_statement
              (integer)))
          alternative: (else_clause
            consequence: (block
              (return_statement
                (binary_operator
                  left: (call
                    function: (double_dollar)
                    arguments: (argument_list
                      argument: (binary_operator
                        left: (identifier)
                        right: (integer))))
                  right: (call
                    function: (double_dollar)
                    arguments: (argument_list
                      argument: (binary_operator
                        left: (identifier)
                        right: (integer)))))))))))))

================================================================================
Procedure definition with no arguments
================================================================================

procedure main()
    print "Hello, World!";
end procedure;

---

(program
  (expression_statement
    (procedure_definition
      name: (identifier)
      parameters: (parameters)
      body: (block
        (print_statement
          (string))))))

================================================================================
Procedure definition and modifying arguments
================================================================================

procedure foobar(~foo, ~bar)
    print foo;
    print bar;
    foo, bar := bar, foo;
end procedure;

---

(program
  (expression_statement
    (procedure_definition
      name: (identifier)
      parameters: (parameters
        (ref_identifier
          (identifier))
        (ref_identifier
          (identifier)))
      body: (block
        (print_statement
          (identifier))
        (print_statement
          (identifier))
        (assignment
          left: (identifier)
          left: (identifier)
          right: (identifier)
          right: (identifier))))))



================================================================================
Procedure definition with := notation
================================================================================

CheckPythagoras := procedure(x, y, z, ~h)
    if x^2+y^2 eq z^2 then
        h := true;
    else
        h := false;
    end if;
end procedure;

---

; adapted from example H2E5
(program
  (assignment
    left: (identifier)
    right: (procedure_definition
      parameters: (parameters
        (identifier)
        (identifier)
        (identifier)
        (ref_identifier
          (identifier)))
      body: (block
        (if_statement
          condition: (binary_operator
            left: (binary_operator
              left: (binary_operator
                left: (identifier)
                right: (integer))
              right: (binary_operator
                left: (identifier)
                right: (integer)))
            right: (binary_operator
              left: (identifier)
              right: (integer)))
          consequence: (block
            (assignment
              left: (identifier)
              right: (true)))
          alternative: (else_clause
            consequence: (block
              (assignment
                left: (identifier)
                right: (false)))))))))

============================
Inline function expressions
============================

myfunc := func<| x + 1>;
myproc := proc<| f(x)>;
func< :Dir | Dir>;

---

(program
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (constructor_elements
        (binary_operator
          left: (identifier)
          right: (integer)))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (constructor_elements
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (identifier))))))
  (expression_statement
    (constructor
      name: (identifier)
      (constructor_elements
        (constructor_options
          (identifier))
        (identifier)))))

============================
Inline functions with parameters
============================

add := func<x, y | x + y>;
print_and_return := proc<~result, value | Print(result, value)>;

---

(program
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (identifier)
      (identifier)
      (constructor_elements
        (binary_operator
          left: (identifier)
          right: (identifier)))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (unary_operator
        right: (identifier))
      (identifier)
      (constructor_elements
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (identifier)
            argument: (identifier)))))))

============================
Optional parameters in procedures
============================

procedure test1(entries:Dir); x := 1; end procedure;
procedure test2(x, y:Default := 5); y := 2; end procedure;
procedure test3(a, b, c, d:Opt2 := 10); z := 3; end procedure;

---

(program
  (expression_statement
    (procedure_definition
      name: (identifier)
      parameters: (parameters
        (identifier)
        (identifier))
      body: (block
        (assignment
          left: (identifier)
          right: (integer)))))
  (expression_statement
    (procedure_definition
      name: (identifier)
      parameters: (parameters
        (identifier)
        (identifier)
        (optional_parameter
          name: (identifier)
          value: (integer)))
      body: (block
        (assignment
          left: (identifier)
          right: (integer)))))
  (expression_statement
    (procedure_definition
      name: (identifier)
      parameters: (parameters
        (identifier)
        (identifier)
        (identifier)
        (identifier)
        (optional_parameter
          name: (identifier)
          value: (integer)))
      body: (block
        (assignment
          left: (identifier)
          right: (integer))))))

============================
Exit statements
============================

try
    x := 1;
    exit NO_RESPAWN;
    y := 2;
catch e
    print "Error:", e;
end try;

---

(program
  (try_catch_statement
    (block
      (assignment
        left: (identifier)
        right: (integer))
      (exit_directive
        (identifier))
      (assignment
        left: (identifier)
        right: (integer)))
    error: (identifier)
    (block
      (print_statement
        (string)
        (identifier)))))

============================
More inline function examples
============================

add := func<x, y | x + y>;
multiply := func<a, b | a * b>;
increment := proc<~x | Append(~x, 1)>;
swap := proc<~a, ~b | Print(a, b)>;
factorial := func<n | n le 1 select 1 else n * $$(n-1)>;
fibonacci := func<n | n le 1 select n else $$(n-1) + $$(n-2)>;

---

(program
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (identifier)
      (identifier)
      (constructor_elements
        (binary_operator
          left: (identifier)
          right: (identifier)))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (identifier)
      (identifier)
      (constructor_elements
        (binary_operator
          left: (identifier)
          right: (identifier)))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (unary_operator
        right: (identifier))
      (constructor_elements
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (unary_operator
              right: (identifier))
            argument: (integer))))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (unary_operator
        right: (identifier))
      (unary_operator
        right: (identifier))
      (constructor_elements
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (identifier)
            argument: (identifier))))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (identifier)
      (constructor_elements
        (binary_operator
          left: (identifier)
          right: (ternary_operator
            conditional: (integer)
            then: (integer)
            else: (binary_operator
              left: (identifier)
              right: (call
                function: (double_dollar)
                arguments: (argument_list
                  argument: (binary_operator
                    left: (identifier)
                    right: (integer))))))))))
  (assignment
    left: (identifier)
    right: (constructor
      name: (identifier)
      (identifier)
      (constructor_elements
        (binary_operator
          left: (identifier)
          right: (ternary_operator
            conditional: (integer)
            then: (identifier)
            else: (binary_operator
              left: (call
                function: (double_dollar)
                arguments: (argument_list
                  argument: (binary_operator
                    left: (identifier)
                    right: (integer))))
              right: (call
                function: (double_dollar)
                arguments: (argument_list
                  argument: (binary_operator
                    left: (identifier)
                    right: (integer)))))))))))

============================
Call function upon definition
============================

a, b := function() return 1, "a"; end function();

---
(program
  (assignment
    left: (identifier)
    left: (identifier)
    right: (call
      function: (function_definition
        parameters: (parameters)
        body: (block
          (return_statement
            (integer)
            (string))))
      arguments: (argument_list))))

