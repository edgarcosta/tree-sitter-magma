================================================================================
Basic intrinsic test
================================================================================

intrinsic test() -> type
{ docstring }
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    return_type: (type
      (identifier))))
    
================================================================================
Intrinsic test with arguments
================================================================================

intrinsic test(x, y) -> .
{ docstring }
  return x + y;
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (identifier)
    parameters: (identifier)
    return_type: (type)
    body: (block
      (return_statement
          (binary_operator
            left: (identifier)
            right: (identifier))))))
	    
================================================================================
Attributes
================================================================================

F`Signature; 
F``"Signature"; 
F``("Signa" cat "ture"); 

---

(program
  (expression_statement
    (attribute
      (identifier)
      (identifier)))
  (expression_statement
    (attribute
      (identifier)
      (string)))
  (expression_statement
    (attribute
      (identifier)
      (parenthesized_expression
        (binary_operator
          left: (string)
          right: (string))))))

================================================================================
Quoted identifier intrinsics (operators)
================================================================================

intrinsic '&+'(S::Setq) -> .
{The sum of all elements of S}
  return InternalAdd(S);
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (typed_identifier
      (identifier)
      (type
        (identifier)))
    return_type: (type)
    body: (block
      (return_statement
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (identifier)))))))

================================================================================
Intrinsic with reference parameters and type annotations
================================================================================

intrinsic Prune(~S::MonStgElt)
{Destructively prune the string S}
  S := S[1..#S-1];
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (ref_typed_identifier
      (identifier)
      (type
        (identifier)))
    body: (block
      (assignment
        left: (identifier)
        right: (seq_slice
          parent: (identifier)
          (seqenum
            (range
              start: (integer)
              end: (binary_operator
                left: (unary_operator
                  right: (identifier))
                right: (integer)))))))))

================================================================================
Intrinsic with reference parameter and any return type
================================================================================

intrinsic Minimum(S::SetMulti) -> .
{The minimum of the elements of S};
  require not IsEmpty(S): "Illegal empty set";
  first := true;
  for x in Set(S) do
      if first then
          first := false;
          min := x;
      else
          min := Min(x, min);
      end if;
  end for;
  return min;
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (typed_identifier
      (identifier)
      (type
        (identifier)))
    return_type: (type)
    body: (block
      (require_statement
        (unary_operator
          right: (call
            function: (identifier)
            arguments: (argument_list
              argument: (identifier))))
        (string))
      (assignment
        left: (identifier)
        right: (true))
      (for_statement
        quantifier: (for_quantifier
          (iterable_binding
            element: (identifier)
            parent: (call
              function: (identifier)
              arguments: (argument_list
                argument: (identifier)))))
        body: (block
          (if_statement
            condition: (identifier)
            consequence: (block
              (assignment
                left: (identifier)
                right: (false))
              (assignment
                left: (identifier)
                right: (identifier)))
            alternative: (else_clause
              consequence: (block
                (assignment
                  left: (identifier)
                  right: (call
                    function: (identifier)
                    arguments: (argument_list
                      argument: (identifier)
                      argument: (identifier)))))))))
      (return_statement
        (identifier)))))

============================
Intrinsic with complex parameter types
============================

intrinsic ComplexIntrinsic(~S::MonStgElt, T::SetEnum, U::SeqEnum[RngIntElt]) -> BoolElt, RngIntElt
{
    This intrinsic demonstrates complex parameter types.
    S is a reference parameter with string type.
    T is a set enumeration.
    U is a sequence of integers.
    Returns a boolean and an integer.
}
    // Implementation would go here
    return true, 42;
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (ref_typed_identifier
      (identifier)
      (type
        (identifier)))
    parameters: (typed_identifier
      (identifier)
      (type
        (identifier)))
    parameters: (typed_identifier
      (identifier)
      (type
        (identifier)
        (type
          (identifier))))
    return_type: (type
      (identifier))
    return_type: (type
      (identifier))
    (comment)
    body: (block
      (return_statement
        (true)
        (integer)))))

============================
Intrinsic with no parameters and no return type
============================

intrinsic SimpleIntrinsic()
{
    A simple intrinsic with no parameters and no return type.
}
    print "Hello from intrinsic!";
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    body: (block
      (print_statement
        (string)))))

============================
Intrinsic with multiple reference parameters
============================

intrinsic SwapIntrinsic(~A::RngIntElt, ~B::RngIntElt)
{
    Swaps two integer values using reference parameters.
}
    temp := A;
    A := B;
    B := temp;
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (ref_typed_identifier
      (identifier)
      (type
        (identifier)))
    parameters: (ref_typed_identifier
      (identifier)
      (type
        (identifier)))
    body: (block
      (assignment
        left: (identifier)
        right: (identifier))
      (assignment
        left: (identifier)
        right: (identifier))
      (assignment
        left: (identifier)
        right: (identifier)))))

============================
Intrinsic with array types
============================

intrinsic ArrayIntrinsic(M::Mtrx, V::SeqEnum[RngIntElt]) -> Mtrx
{
    An intrinsic that works with matrix and sequence types.
}
    return M;
end intrinsic;

---

(program
  (intrinsic_definition
    name: (identifier)
    parameters: (typed_identifier
      (identifier)
      (type
        (identifier)))
    parameters: (typed_identifier
      (identifier)
      (type
        (identifier)
        (type
          (identifier))))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (identifier)))))
